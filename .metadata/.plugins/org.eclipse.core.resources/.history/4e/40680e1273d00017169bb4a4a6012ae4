package ver1;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

import ownapi.*;
import ver1.util.*;

public class Backtracker {
	
	/**
	 * Backtracking element
	 * @author Oriol Miro-Barcelo
	 *
	 */
	class BTElement {
		/**
		 * Tracking element. Contains a node and an OWNAxiom
		 * @author Oriol Miro-Barcelo
		 *
		 */
		class Tracker {
			private Pair<Node, OWNAxiom> tracker;
			
			public Tracker(Node n, OWNAxiom axiom) {
				tracker = new Pair<Node, OWNAxiom>(n, axiom);
			}
			
			public boolean isEqual(Tracker t) {
				return this.tracker.equals(t.tracker);
			}
			
			@Override
			public int hashCode() {
				return tracker.hashCode();
			}
			
			@Override
			public boolean equals(Object other) {
				return tracker.equals(other);
			}
		}
		
		
		private NonDeterministicOperation NDO;
		private Snapshot snapshot;
		private List<Tracker> trackers;
		
		/**
		 * The result of the NDO is added to the tracker list
		 * @param NDO
		 * @param snapshot
		 */
		public BTElement(NonDeterministicOperation NDO, Snapshot snapshot) {
			this.NDO = NDO;
			this.snapshot = snapshot;
			this.trackers = new ArrayList<Tracker>();
			this.trackers.add(new Tracker(NDO.getNode(), NDO.getResult()));
		}
		
		/**
		 * Check if the tracker with (n, axiom) is contained and updates it to (updatedNode, results)
		 * @param n
		 * @param axiom
		 * @param updatedNode
		 * @param results
		 */
		public void updateTrackers(Node n, OWNAxiom axiom, Node updatedNode, OWNAxiom... results) {
			Tracker t = new Tracker(n, axiom);
			for (Tracker tr : trackers) {
				boolean equal = tr.equals(t);
				System.out.println(equal);
			}
			if (trackers.contains(t)) {
				trackers.remove(t);
				for (OWNAxiom ax : results) {
					trackers.add(new Tracker(updatedNode, ax));
				}
			}
		}
		
		public boolean containsTracker(Node n, OWNAxiom axiom) {
			return trackers.contains(new Tracker(n, axiom));
		}
	}
	
	
	private List<BTElement> backtracker;
	private Pair<NonDeterministicOperation, Snapshot> clashCause;

	public Backtracker() {
		this.backtracker = new ArrayList<BTElement>();
		clashCause = null;
	}
	
	public void takeSnapshot(NonDeterministicOperation ndo, Tableau tableau) {
		Snapshot snapshot = new Snapshot(tableau);
		backtracker.add(new BTElement(ndo, snapshot));
	}
	
	public void updateTrackers(Node n, OWNAxiom axiom, Node updatedNode, OWNAxiom... results) {
		// TODO
		for (BTElement elem : backtracker) {
			elem.updateTrackers(n, axiom, updatedNode, results);
		}
	}
	
	public boolean isAxiomTracked(Node n, OWNAxiom axiom) {
		// TODO
		for (BTElement elem : backtracker) {
			return elem.containsTracker(n, axiom);
		}
		return false;
	}
	
	public void selectCauseOfClash(Node n, OWNAxiom axiom) {
		// TODO get clashCause
		for (BTElement elem : backtracker) {
			if (elem.containsTracker(n, axiom)) {
				clashCause = new Pair<NonDeterministicOperation, Snapshot>(elem.NDO, elem.snapshot);
			}
		}
	}
	
	public Pair<NonDeterministicOperation, Snapshot> getCauseOfClash() {
		return clashCause;
	}
	
	public boolean thereAreSnapshots() {
		return !backtracker.isEmpty();
	}
	
//	/**
//	 * Peek at which non deterministic operation created the last snapshot
//	 * @return
//	 */
//	public OWNAxiom checkLastNDOAxiom() {
//		Pair<NonDeterministicOperation, Snapshot> p = timeline.peek();
//		return p.getFirst().getOperand();
//	}
//	
//	public Pair<NonDeterministicOperation, Snapshot> getLastSnapshot() {
//		return timeline.pop();
//	}
//		
//	public boolean thereAreSnapshots() {
//		return !timeline.isEmpty();
//	}
	
}
